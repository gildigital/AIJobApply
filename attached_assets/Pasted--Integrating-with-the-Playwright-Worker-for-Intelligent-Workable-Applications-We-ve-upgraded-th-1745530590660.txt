## Integrating with the Playwright Worker for Intelligent Workable Applications

We've upgraded the Playwright Worker (Node.js + Playwright service) to enable a dynamic, schema-driven automation system for Workable job applications. Instead of hardcoding selectors, the Worker can now introspect each form and fill it based on its exact structure.

Your Replit application will act as the orchestrator, following this two-phase workflow:

### üß© Phase 1: Introspect the Form

**Goal:** Understand the structure of the Workable application form by asking the Worker to scrape it.

**Action:** Make a **POST** request from your Replit App to the Playwright Worker‚Äôs `/introspect` endpoint.

**Request Body (JSON):**

```json
{
  "job": {
    "applyUrl": "[https://jobs.workable.com/view/](https://jobs.workable.com/view/)..."
  }
}
Worker Response (JSON Example - if successful):

JSON

{
  "status": "success",
  "fields": [
    { "name": "first_name", "label": "First Name", "type": "text", "required": true },
    { "name": "last_name", "label": "Last Name", "type": "text", "required": true },
    { "name": "email", "label": "Email", "type": "email", "required": true },
    { "name": "phone", "label": "Phone", "type": "tel", "required": false },
    { "name": "upload_resume", "label": "Upload your CV / Resume", "type": "file", "required": true },
    { "name": "cover_letter", "label": "Cover Letter", "type": "textarea", "required": false },
    // ... potentially many more fields depending on the specific job form
  ]
}
Your Task in Phase 1:

Send the POST request to the Worker's /introspect endpoint.
Receive and parse the JSON response.
Parse and ideally store the fields schema, associating it with the specific job (e.g., using the applyUrl as a key).
Analyze the schema to understand the names (name), types (type), labels (label), and requirement status (required) of each field.
Determine which fields match the data you have available for the user.
‚úçÔ∏è Phase 2: Prepare Data & Submit Application
Goal: Use the schema to prepare the application data and send it back to the Worker for dynamic filling and submission.

Action: Once you have the schema and have prepared the data, make a POST request from your Replit App to the Playwright Worker‚Äôs /submit endpoint.

Request Body (JSON):

JSON

{
  "job": {
    "applyUrl": "[https://jobs.workable.com/view/](https://jobs.workable.com/view/)..." // Still needed for navigation
  },
  "formData": {
    "first_name": "Gil",
    "last_name": "Martinez",
    "email": "gil@example.com",
    "phone": "123-456-7890", // Include only if you have the data and want to fill
    "upload_resume": "/app/uploads/gil_resume.pdf", // **Local path accessible by the Worker**
    "cover_letter": "Dear team, I'm excited to apply...", // Opportunity for LLM generated response!!!
    "custom_question_name": "Answer to the custom question" // Opportunity for LLM generated response!!!
    // ... include keys (matching schema names) and values for ALL fields you want to fill
    // ... there may be many other LLM implementation opportunities
  }
}
Worker Response (JSON Example):

JSON

{
  "status": "success",
  "message": "Application submitted via Workable modal."
}
or

JSON

{
  "status": "fail",
  "error": "Timeout while filling resume field" // Or other Playwright errors
}

Your Task in Phase 2:

Retrieve the stored schema for the target job.
Gather the user's standard data.
Use your logic (including AI generation for text fields like summary, cover letter, or custom questions) to prepare the content for each field you intend to fill based on the schema.
Construct the formData JSON object. The keys must exactly match the name attributes returned in the /introspect schema.
Send the POST request with the job URL and the formData payload to the Worker's /submit endpoint.
Handle the Worker's success or failure response, updating the job status in your application accordingly.

üõ† Implementation Tips for Your Replit App:
HTTP Client: Use an appropriate library in your Replit App's language (e.g., Net::HTTP or a gem like httparty if using Ruby/Rails, axios or node-fetch if Node.js) to make POST requests to the Playwright Worker's API endpoints.
formData Keys: This is critical. Ensure the keys in your formData payload ("first_name", "upload_resume", "cover_letter", etc.) are taken directly from the name property you received for each field in the /introspect schema.
Skipping Fields: You do not need to include keys in formData for fields you don't want to fill (e.g., optional fields you are skipping). The Worker will only attempt to fill fields present in the formData payload. Also, the Worker is designed to skip filling if a value in formData is empty (null, undefined, or "").

File Paths: For type: "file" fields, the value in formData must be the absolute path to the file on the filesystem where the Playwright Worker is running. Ensure the Worker has permission to access this path. You might need a file transfer mechanism if your Replit App and Worker don't share the same filesystem.

Dynamic Content: Leverage your AI capabilities to generate tailored content (cover letters, summaries, answers to open questions) based on the job description and the user's profile, then map this generated text to the appropriate field name in your formData.
Required Fields: Before calling /submit, check the schema for required: true fields. If you don't have data for a required field, you might need to flag the job for manual completion or use a default value if acceptable. The Worker itself might fail the submission if required fields are left empty, but your Replit App should handle this check proactively.

üí° Edge Cases to Handle:
Introspection Failure: If the /introspect call fails ("status": "fail") or returns an empty fields array, log the error and potentially skip or flag the job as unable to be automated.
Submission Failure: If the /submit call returns "status": "fail", log the error message from the Worker (error field) to understand why it failed (e.g., a specific field couldn't be filled, a final submit button wasn't found). Mark the job as failed or needing manual intervention.
File Existence: Before including a file path in formData, verify that the file actually exists at that path accessible by the Worker.
Data Mapping: Ensure your logic correctly maps your internal user data fields (like user.phone) to the potentially varying name attributes returned by the schema ("phone", "phoneNumber", "contact_number", etc.). This mapping logic lives in your Replit App.